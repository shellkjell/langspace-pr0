// Package typescript provides TypeScript/Vercel AI SDK code generation for LangSpace.
package typescript

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/shellkjell/langspace/pkg/ast"
	"github.com/shellkjell/langspace/pkg/compile"
	"github.com/shellkjell/langspace/pkg/workspace"
)

func init() {
	compile.Register(&Generator{})
}

// Generator generates TypeScript/Vercel AI SDK code from LangSpace definitions.
type Generator struct{}

// Target returns the compilation target.
func (g *Generator) Target() compile.Target {
	return compile.TargetTypeScript
}

// Compile generates TypeScript code for the given workspace.
func (g *Generator) Compile(ws *workspace.Workspace) (*compile.Output, error) {
	output := &compile.Output{
		Files: make(map[string]string),
	}

	// Collect all entities by type
	agents := ws.GetEntitiesByType("agent")
	pipelines := ws.GetEntitiesByType("pipeline")
	intents := ws.GetEntitiesByType("intent")
	configs := ws.GetEntitiesByType("config")

	// Generate main code
	mainCode, err := g.generateMain(agents, pipelines, intents, configs)
	if err != nil {
		return nil, fmt.Errorf("generating main: %w", err)
	}
	output.Files["index.ts"] = mainCode

	// Generate package.json
	output.Files["package.json"] = g.generatePackageJSON()

	// Generate .env template
	output.Files[".env.example"] = g.generateEnvExample()

	return output, nil
}

func (g *Generator) generateMain(agents, pipelines, intents, configs []ast.Entity) (string, error) {
	var buf bytes.Buffer

	// Write imports
	buf.WriteString(tsImports)

	// Write config
	if len(configs) > 0 {
		g.writeConfig(&buf, configs[0])
	} else {
		buf.WriteString("\nconst DEFAULT_MODEL = 'claude-3-5-sonnet-20240620';\n")
	}

	// Write agents
	for _, agent := range agents {
		if err := g.writeAgent(&buf, agent); err != nil {
			return "", err
		}
	}

	// Write pipelines
	for _, pipeline := range pipelines {
		if err := g.writePipeline(&buf, pipeline); err != nil {
			return "", err
		}
	}

	// Write intents
	for _, intent := range intents {
		if err := g.writeIntent(&buf, intent); err != nil {
			return "", err
		}
	}

	// Write runner
	buf.WriteString(tsRunner)

	return buf.String(), nil
}

func (g *Generator) writeConfig(buf *bytes.Buffer, config ast.Entity) {
	model := getStringProp(config, "default_model", "claude-3-5-sonnet-20240620")
	fmt.Fprintf(buf, "\nconst DEFAULT_MODEL = '%s';\n", model)
}

func (g *Generator) writeAgent(buf *bytes.Buffer, agent ast.Entity) error {
	name := agent.Name()
	safeName := toCamelCase(name)
	model := getStringProp(agent, "model", "DEFAULT_MODEL")
	temperature := getNumberProp(agent, "temperature", 0.7)
	instruction := getStringProp(agent, "instruction", "You are a helpful assistant.")

	tmpl := template.Must(template.New("tsAgent").Funcs(funcMap).Parse(tsAgentTemplate))
	return tmpl.Execute(buf, map[string]interface{}{
		"Name":        name,
		"SafeName":    safeName,
		"Model":       model,
		"Temperature": temperature,
		"Instruction": instruction,
	})
}

func (g *Generator) writePipeline(buf *bytes.Buffer, pipeline ast.Entity) error {
	name := pipeline.Name()
	safeName := toCamelCase(name)

	var steps []map[string]string
	for _, val := range pipeline.Properties() {
		if nested, ok := val.(ast.NestedEntityValue); ok {
			if nested.Entity.Type() == "step" {
				stepName := nested.Entity.Name()
				usesAgent := ""
				if useVal, exists := nested.Entity.GetProperty("use"); exists {
					if ref, ok := useVal.(ast.ReferenceValue); ok && ref.Type == "agent" {
						usesAgent = ref.Name
					}
				}
				steps = append(steps, map[string]string{
					"name":      stepName,
					"safeName":  toCamelCase(stepName),
					"usesAgent": toCamelCase(usesAgent),
				})
			}
		}
	}

	tmpl := template.Must(template.New("tsPipeline").Funcs(funcMap).Parse(tsPipelineTemplate))
	return tmpl.Execute(buf, map[string]interface{}{
		"Name":     name,
		"SafeName": safeName,
		"Steps":    steps,
	})
}

func (g *Generator) writeIntent(buf *bytes.Buffer, intent ast.Entity) error {
	name := intent.Name()
	safeName := toCamelCase(name)

	usesAgent := ""
	usesPipeline := ""
	if useVal, exists := intent.GetProperty("use"); exists {
		if ref, ok := useVal.(ast.ReferenceValue); ok {
			switch ref.Type {
			case "agent":
				usesAgent = toCamelCase(ref.Name)
			case "pipeline":
				usesPipeline = toCamelCase(ref.Name)
			}
		}
	}

	tmpl := template.Must(template.New("tsIntent").Funcs(funcMap).Parse(tsIntentTemplate))
	return tmpl.Execute(buf, map[string]interface{}{
		"Name":         name,
		"SafeName":     safeName,
		"UsesAgent":    usesAgent,
		"UsesPipeline": usesPipeline,
	})
}

func (g *Generator) generatePackageJSON() string {
	return `{
  "name": "langspace-workflow",
  "version": "1.0.0",
  "description": "Generated by LangSpace",
  "main": "index.ts",
  "scripts": {
    "start": "ts-node index.ts"
  },
  "dependencies": {
    "ai": "^4.0.0",
    "@ai-sdk/anthropic": "^1.0.0",
    "@ai-sdk/openai": "^1.0.0",
    "dotenv": "^16.4.5",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "ts-node": "^10.9.2",
    "typescript": "^5.5.0"
  }
}
`
}

func (g *Generator) generateEnvExample() string {
	return `ANTHROPIC_API_KEY=your_key_here
OPENAI_API_KEY=your_key_here
`
}

var funcMap = template.FuncMap{
	"title": toTitle,
}

func toTitle(s string) string {
	if len(s) == 0 {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// Helpers

func toCamelCase(s string) string {
	s = strings.ReplaceAll(s, "-", " ")
	s = strings.ReplaceAll(s, "_", " ")
	words := strings.Fields(s)
	if len(words) == 0 {
		return ""
	}
	res := strings.ToLower(words[0])
	for i := 1; i < len(words); i++ {
		res += toTitle(words[i])
	}
	return res
}

func getStringProp(entity ast.Entity, key, defaultVal string) string {
	if val, exists := entity.GetProperty(key); exists {
		if sv, ok := val.(ast.StringValue); ok {
			return sv.Value
		}
	}
	return defaultVal
}

func getNumberProp(entity ast.Entity, key string, defaultVal float64) float64 {
	if val, exists := entity.GetProperty(key); exists {
		if nv, ok := val.(ast.NumberValue); ok {
			return nv.Value
		}
	}
	return defaultVal
}

const tsImports = `import { generateText } from 'ai';
import { anthropic } from '@ai-sdk/anthropic';
import { openai } from '@ai-sdk/openai';
import * as dotenv from 'dotenv';

dotenv.config();

function getModel(modelName: string) {
  if (modelName.startsWith('claude')) {
    return anthropic(modelName);
  }
  return openai(modelName);
}
`

const tsAgentTemplate = `
/**
 * Agent: {{.Name}}
 */
export async function {{.SafeName}}(input: string) {
  const { text } = await generateText({
    model: getModel({{.Model}} === 'DEFAULT_MODEL' ? DEFAULT_MODEL : {{.Model}}),
    system: ` + "`" + `{{.Instruction}}` + "`" + `,
    prompt: input,
    temperature: {{.Temperature}},
  });
  return text;
}
`

const tsPipelineTemplate = `
/**
 * Pipeline: {{.Name}}
 */
export async function {{.SafeName}}(input: string) {
  let currentOutput = input;
  
  {{- range .Steps}}
  // Step: {{.name}}
  currentOutput = await {{.usesAgent}}(currentOutput);
  {{- end}}
  
  return currentOutput;
}
`

const tsIntentTemplate = `
/**
 * Intent: {{.Name}}
 */
export async function run{{.Name | title}}(input: string) {
{{- if .UsesAgent}}
  return await {{.UsesAgent}}(input);
{{- else if .UsesPipeline}}
  return await {{.UsesPipeline}}(input);
{{- else}}
  return input;
{{- end}}
}
`

const tsRunner = `
if (require.main === module) {
  const input = process.argv.slice(2).join(' ') || 'Hello LangSpace';
  console.log('Input:', input);
  // Add entry point call here
}
`
